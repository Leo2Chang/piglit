# This test checks that the vertex shader outputs gl_FrontColor and
# gl_BackColor are correctly mapped to the fragment shader input
# gl_Color.
#
# It does so by setting up the vertex and fragment shaders to render a
# rectangle whose front side is red and whose back side is green.
# Then, using the shader_runner "ortho" command, it sets up
# transformations that cause both the front and the back side of the
# rectangle to be rendered.
#
# In this test, the vertex shader outputs a value for gl_PointSize.

[require]
GLSL >= 1.10

[vertex shader]
void main()
{
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
  gl_FrontColor = vec4(1.0, 0.0, 0.0, 1.0); /* red */
  gl_BackColor = vec4(0.0, 1.0, 0.0, 1.0); /* green */
  gl_PointSize = 1.0;
}

[fragment shader]
void main()
{
  gl_FragColor = gl_Color;
}

[test]
# I think this is all that should be needed to enable two-sided color.
enable GL_VERTEX_PROGRAM_TWO_SIDE

# But mesa seems to require these too:
enable GL_LIGHTING
set GL_LIGHT_MODEL_TWO_SIDE 1

# Render the front of the rectangle and check that it's red
ortho 0 1 0 1
draw rect 0 0 1 1
probe all rgba 1 0 0 1

# Render the back of the rectangle and check that it's green
ortho 1 0 0 1
draw rect 0 0 1 1
probe all rgba 0 1 0 1
